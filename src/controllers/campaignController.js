  // controllers/campaignController.js
  const { check } = require('express-validator');
  const campaignService = require('../services/campaignService');
  const validate = require('../middleware/validationMiddleware');
  const { uploadToCloudinary, deleteFromCloudinary } = require('../utils/cloudinaryUpload');


  // ================== PUBLIC ==================

  /**
   * GET /api/campaigns
   */
  exports.getAllCampaigns = async (req, res, next) => {
    try {
      const campaigns = await campaignService.getAllCampaigns(req.query);
      res.json(campaigns);
    } catch (error) {
      next(error);
    }
  };

  /**
   * GET /api/campaigns/:id
   */
  exports.getCampaignById = async (req, res, next) => {
    try {
      const campaign = await campaignService.getCampaignById(req.params.id);
      res.json(campaign);
    } catch (error) {
      next(error);
    }
  };

  /**
   * GET /api/campaigns/featured
   */
  exports.getFeaturedCampaigns = async (req, res, next) => {
    try {
      const { limit = 6 } = req.query;
      const campaigns = await campaignService.getAllCampaigns({
        featured: true,
        limit,
        page: 1,
        sort: 'created_at',
        order: 'DESC',
      });
      res.json(campaigns);
    } catch (error) {
      next(error);
    }
  };

  /**
   * GET /api/campaigns/categories
   */
  exports.getCategories = async (req, res, next) => {
    try {
      const categories = [
        { id: 'education',  name: 'Gi√°o d·ª•c',              icon: 'üéì' },
        { id: 'health',     name: 'Y t·∫ø',                  icon: 'üè•' },
        { id: 'environment',name: 'M√¥i tr∆∞·ªùng',            icon: 'üå±' },
        { id: 'poverty',    name: 'X√≥a ƒë√≥i gi·∫£m ngh√®o',    icon: 'üçö' },
        { id: 'disaster',   name: 'C·ª©u tr·ª£ thi√™n tai',     icon: 'üÜò' },
        { id: 'children',   name: 'Tr·∫ª em',                icon: 'üë∂' },
        { id: 'elderly',    name: 'Ng∆∞·ªùi cao tu·ªïi',        icon: 'üë¥' },
        { id: 'disability', name: 'Ng∆∞·ªùi khuy·∫øt t·∫≠t',      icon: '‚ôø' },
        { id: 'animals',    name: 'B·∫£o v·ªá ƒë·ªông v·∫≠t',       icon: 'üêï' },
        { id: 'community',  name: 'C·ªông ƒë·ªìng',             icon: 'üèòÔ∏è' },
      ];
      res.json(categories);
    } catch (error) {
      next(error);
    }
  };

  // ================== CREATE / UPDATE / DELETE ==================

  /**
   * POST /api/campaigns
   * Y√™u c·∫ßu: authMiddleware + requireCharity + upload.fields([{ image, images, qr_image }])
   * FE KH√îNG g·ª≠i charity_id; l·∫•y t·ª´ req.user (JWT)
   */
  exports.create = [
    check('title').notEmpty().withMessage('Ti√™u ƒë·ªÅ l√† b·∫Øt bu·ªôc'),
    check('goal_amount').isFloat({ min: 0 }).withMessage('S·ªë ti·ªÅn m·ª•c ti√™u kh√¥ng h·ª£p l·ªá'),
    validate,
    async (req, res, next) => {
      try {
        // 1) L·∫•y charity_id t·ª´ token
        const charity_id =
          req.user?.charity_id ||
          req.user?.charity?.charity_id ||
          null;

        if (!charity_id) {
          return res.status(403).json({
            status: 'error',
            message: 'T√†i kho·∫£n kh√¥ng c√≥ quy·ªÅn charity ho·∫∑c thi·∫øu charity_id trong token',
          });
        }

        // 2) Chu·∫©n ho√° file -> URL public (/uploads/campaigns/<filename>)
        const fileToUrl = (f) => (f ? `/uploads/campaigns/${f.filename}` : null);

        const image_url      = fileToUrl(req.files?.image?.[0]);                       // ·∫£nh ƒë·∫°i di·ªán
        const gallery_images = (req.files?.images || []).map(fileToUrl).filter(Boolean); // m·∫£ng URL
        const qr_code_url    = fileToUrl(req.files?.qr_image?.[0]);                    // QR

        // 3) Payload t·∫°o campaign
        const payload = {
          ...req.body,
          charity_id,
          image_url,
          gallery_images,
          qr_code_url,
        };

        // 4) T·∫°o campaign
        const campaign = await campaignService.create(payload);
        res.status(201).json(campaign);
      } catch (error) {
        next(error);
      }
    },
  ];

  /**
   * PUT /api/campaigns/:id
   */
  exports.update = [
    check('title').optional().notEmpty().withMessage('Ti√™u ƒë·ªÅ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'),
    validate,
    async (req, res, next) => {
      try {
        const campaign = await campaignService.update(req.params.id, req.body);
        res.json(campaign);
      } catch (error) {
        next(error);
      }
    },
  ];

  /**
   * DELETE /api/campaigns/:id
   */
  exports.delete = async (req, res, next) => {
    try {
      await campaignService.delete(req.params.id);
      res.json({ message: 'ƒê√£ x√≥a chi·∫øn d·ªãch' });
    } catch (error) {
      next(error);
    }
  };

  // ================== UPLOAD RI√äNG (tu·ª≥ ch·ªçn d√πng) ==================

  /**
   * POST /api/campaigns/:id/upload-image  (field: image)
   */
  exports.uploadImage = async (req, res, next) => {
    try {
      const result = await campaignService.uploadImage(
        req.params.id,
        req.file,
        req.user.user_id
      );
      res.json(result);
    } catch (error) {
      next(error);
    }
  };

  /**
   * POST /api/campaigns/:id/upload-images (field: images[])
   */
  exports.uploadImages = async (req, res, next) => {
    try {
      const result = await campaignService.uploadImages(
        req.params.id,
        req.files,
        req.user.user_id
      );
      res.json(result);
    } catch (error) {
      next(error);
    }
  };
    // ====== Updates (Ho·∫°t ƒë·ªông) ======
  const Campaign = require('../models/Campaign');
  const crypto = require('crypto');

  // GET /api/campaigns/:id/updates?page=&limit=
  exports.getCampaignUpdates = async (req, res, next) => {
    try {
      const { id } = req.params;
      const page  = Math.max(parseInt(req.query.page  || '1', 10), 1);
      const limit = Math.min(Math.max(parseInt(req.query.limit || '5', 10), 1), 50);

      const campaign = await Campaign.findOne({ where: { campaign_id: id } });
      if (!campaign) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y chi·∫øn d·ªãch' });

      const list = Array.isArray(campaign.progress_updates) ? campaign.progress_updates : [];
      // sort desc theo created_at
      const sorted = [...list].sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));

      const total = sorted.length;
      const totalPages = Math.max(Math.ceil(total / limit), 1);
      const offset = (page - 1) * limit;
      const items = sorted.slice(offset, offset + limit);

      return res.json({ page, limit, total, totalPages, updates: items });
    } catch (err) {
      next(err);
    }
  };

  // POST /api/campaigns/:id/updates  (multipart images[])
  exports.createCampaignUpdate = async (req, res, next) => {
    try {
      const { id } = req.params;

      const campaign = await Campaign.findOne({ where: { campaign_id: id } });
      if (!campaign) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y chi·∫øn d·ªãch' });

      const { title, content, spent_amount } = req.body;
      if (!title && !content) {
        return res.status(400).json({ message: 'C·∫ßn √≠t nh·∫•t ti√™u ƒë·ªÅ ho·∫∑c n·ªôi dung.' });
      }

      // spent_items: JSON string -> array [{label, amount}]
      let spent_items = null;
      if (req.body.spent_items) {
        try {
          const parsed = JSON.parse(req.body.spent_items);
          if (Array.isArray(parsed)) {
            const cleaned = parsed
              .filter((it) => (it.label?.trim() || '') !== '' || !isNaN(Number(it.amount)))
              .map((it) => ({ label: String(it.label || '').trim(), amount: Number(it.amount || 0) }));
            if (cleaned.length) spent_items = cleaned;
          }
        } catch {
          return res.status(400).json({ message: 'spent_items kh√¥ng ph·∫£i JSON h·ª£p l·ªá' });
        }
      }

       const images = [];
    if (req.files && req.files.length > 0) {
      for (const file of req.files) {
        try {
          // Upload t·ª´ buffer l√™n Cloudinary
          const cloudinaryUrl = await uploadToCloudinary(
            file.buffer,
            `campaigns/${id}/updates` // Folder tr√™n Cloudinary
          );
          images.push(cloudinaryUrl);
        } catch (uploadErr) {
          console.error('L·ªói upload ·∫£nh l√™n Cloudinary:', uploadErr);
          // C√≥ th·ªÉ skip ho·∫∑c throw error t√πy y√™u c·∫ßu
          // ·ªû ƒë√¢y m√¨nh skip ·∫£nh l·ªói, ti·∫øp t·ª•c upload ·∫£nh kh√°c
        }
      }
    }
      const authorId = String(req.user?.user_id || req.user?.id || '');
      const now = new Date().toISOString();

      const newUpdate = {
        id: crypto.randomUUID(),
        created_at: now,
        created_by: authorId,
        title: title || null,
        content: content || '',
        spent_amount:
          spent_amount != null && String(spent_amount).trim() !== ''
            ? Number(spent_amount)
            : null,
        spent_items, // c√≥ th·ªÉ null
        images,      // []
      };

   // controllers/campaignController.js -> createCampaignUpdate

const arr = Array.isArray(campaign.progress_updates) ? campaign.progress_updates : [];
arr.push(newUpdate);

await Campaign.update(
  { progress_updates: arr, updated_at: new Date() },
  { where: { campaign_id: id } }
);

// (tu·ª≥ ch·ªçn) l·∫•y l·∫°i d·ªØ li·ªáu m·ªõi ƒë·ªÉ tr·∫£ ra
const saved = await Campaign.findOne({ where: { campaign_id: id } });

return res.status(201).json({
  message: 'T·∫°o c·∫≠p nh·∫≠t th√†nh c√¥ng',
  update: newUpdate,
  total_updates: saved?.progress_updates?.length || arr.length
});

    } catch (err) {
      next(err);
    }
  };
// DELETE /api/campaigns/:id/updates/:updateId
exports.deleteCampaignUpdate = async (req, res, next) => {
  try {
    const { id, updateId } = req.params;

    const campaign = await Campaign.findOne({ where: { campaign_id: id } });
    if (!campaign) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y chi·∫øn d·ªãch' });

    const list = Array.isArray(campaign.progress_updates) ? campaign.progress_updates : [];
    const upd = list.find(u => String(u.id) === String(updateId));
    if (!upd) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y c·∫≠p nh·∫≠t c·∫ßn xo√°' });

    // (tu·ª≥ ch·ªçn) Ch·ªâ admin ho·∫∑c ch√≠nh ng∆∞·ªùi t·∫°o update ƒë∆∞·ª£c xo√°:
    const me = String(req.user?.user_id || req.user?.id || '');
    if (req.user.role !== 'admin' && String(upd.created_by || '') !== me) {
      return res.status(403).json({ message: 'B·∫°n kh√¥ng th·ªÉ xo√° c·∫≠p nh·∫≠t c·ªßa ng∆∞·ªùi kh√°c' });
    }
    if (upd.images && Array.isArray(upd.images) && upd.images.length > 0) {
      for (const imageUrl of upd.images) {
        try {
          await deleteFromCloudinary(imageUrl);
        } catch (delErr) {
          console.error('L·ªói x√≥a ·∫£nh Cloudinary:', delErr);
          // Kh√¥ng throw error, ti·∫øp t·ª•c x√≥a record
        }
      }
    }

    campaign.progress_updates = list.filter(u => String(u.id) !== String(updateId));
    await campaign.save();

    return res.json({ message: 'ƒê√£ xo√° c·∫≠p nh·∫≠t th√†nh c√¥ng', updateId });
  } catch (err) {
    next(err);
  }
};
